Flutter的动画逻辑相对来说还是比较清晰的，AnimationController用于对动画的控制，开始，结束，反向播放等，Curve用于描述动画的过程特性，加速，减速等，
Animatable或者Tween及其子类用于包装需要的最终的结果类型，由于AnimationController一般是从0.0到1.0之间变化，
因此在Tween中需要通过设置begin属性和end属性来进行映射。Animation就是最终得到的动画对象，
通过将不同时刻Animation的value值赋值给不同的对象来实现让对象动起来的效果。


/ Flutter的动画相关类 /
首先来看下Flutter的动画基础概念和相关类，如下所示：

Animation：Flutter中动画的核心类
AnimationController：动画管理类
CurvedAnimation：用于定义非线性曲线动画
Tween：补间对象，用于计算动画使用的数据范围之间的插值。
Listeners和StatusListeners：用于监听动画状态改变
Animation介绍

Flutter中的动画核心类，我们可以理解为Animation是Flutter中动画的基类。它是个抽象类（abstract），所以不能够直接创建其对象来使用动画。Animation具有以下特性：
Animation对象知道动画的当前状态（例如，它是开始、停止还是向前或向后移动），但它不知道屏幕上显示的内容。
Flutter中的Animation对象是一个在一段时间内依次生成一个区间之间值的类。Animation对象的输出可以是线性的、曲线的、一个步进函数或者任何其他可以设计的映射。根据Animation对象的控制方式，动画可以反向运行，甚至可以在中间切换方向。
Animation还可以生成除double之外的其他类型值，如：Animation<Color> 或 Animation<Size>。
Animation对象有状态，可以通过访问其value属性获取动画的当前值。
Animation对象本身和UI渲染没有任何关系。

AnimationController
   AnimationController 是一个特殊的Animation对象，在屏幕刷新的没一帧，就会生成一个新的值，默认情况下，AnimationController在给定的时间段内会线性的生成从0.0到1.0的数字，如：下面代码创建一个Animation对象
  final AnimationController controller = new AnimationController(duration:const Duration(millisecons:2000),vsync:this);
  AnimationController派生自Animation因此可以在需要Animation的任何地方使用。但是，AnimationController 具体控制动画的其他方法：
  # forward ：启动动画
  # reverse({double from}):倒放动画
  # reset() :重置动画，将其设置到动画的开始位置
  # stop（{bool canceled = true}）:停止动画
  当创建一个AnimationController 时，需要传递一个vsync参数。存在vsync时，回防止屏幕外动画消耗不必要的资源，可以将stateful对象作为vsync的值
  
=================
最基本的动画.
继承with SingleTickerProviderStateMixin

定义一个动画管理器
AnimationController ctl;
@override
void initState() {
 super.initState();
 this.ctl = AnimationController(
 duration:Duration(milliseconds:5000),
 vsync: this)..addListener((){
   setState(
     (){

     }
   );
 });
 和释放函数
 @override
  void dispose() {
    this.ctl.dispose();
    super.dispose();
  }
  
在需要变换的控件方面加上变化参数
Container(
width: 100 * ctl.value,

==========================================
使用速度曲线
继承 Animation<double>，生成 double 值。

final CurvedAnimation curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);
第二个参数是 Curve 对象，表示动画曲线函数，类似 Android 动画的插值器。有一些内置曲线

static const Curve linear = _Linear._();
static const Curve decelerate = _DecelerateCurve._(); // 相当于 Android 的 DecelerateInterpolator
这些内置对象就是继承了 Curve 类，重写 transform 方法，如

class _Linear extends Curve {
  const _Linear._();

  @override
  double transform(double t) => t;
}
因而可以自定义任何函数：

class ShakeCurve extends Curve {
  @override
  double transform(double t) {
    return math.sin(t * math.PI * 2);
  }
}
Curve 有一子类 Cubic，是贝塞尔曲线，又定义了它的若干实例，如
static const Cubic ease = Cubic(0.25, 0.1, 0.25, 1.0);
static const Cubic easeIn = Cubic(0.42, 0.0, 1.0, 1.0);

增加速度曲线
@override
initState() {
 super.initState();
 controller = AnimationController(
     duration: const Duration(milliseconds: 5000), vsync: this);
 // 创建一个 CurvedAnimation，监听它的 value
 curve = CurvedAnimation(parent: controller, curve: Curves.easeIn)
   ..addListener(() {
     setState(() {

     });
   });
 controller.forward();
}

============================
更改不同生产范围
AnimationController 对象的默认范围从 0.0 到 1.0。如果需要不同的范围或不同的数据类型，则可以使用 Tween 来配置动画以生成不同的范围或数据类型的值。

// 生成 -200.0 到 0.0 的数值
final Tween doubleTween = Tween<double>(begin: -200.0, end: 0.0);
Tween 是 stateless 的，需要 begin 和 end 值
唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为 0.0 到 1.0，但并不一定
继承 Animatable<T>，而不是继承 Animation<T>，泛型不一定要是 double。如
final Tween colorTween =     ColorTween(begin: Colors.transparent, end: Colors.black54);

final AnimationController controller = AnimationController(
    duration: const Duration(milliseconds: 500), vsync: this);
// 在 500 毫秒内生成从 0 到 255 的整数值，返回一个 Animation 对象
Animation<int> alpha = IntTween(begin: 0, end: 255).animate(controller);

或者
controller = AnimationController(
      duration: const Duration(milliseconds: 2000), vsync: this);
  // 创建一个 Tween，值从 0 到 300
  animation = Tween(begin: 0.0, end: 300.0).animate(controller)
    ..addListener(() { // 给这个 Animation 添加监听
      setState(() {
        print('${controller.value}-${animation.value}');
      });
    });
  controller.forward();
 
 在 2000ms 内，AnimationController 的 value 从 0.0 到 1.0，同时 Tween 的 value 从 0.0 到 300.0。
 也可以用 CurvedAnimation 对象作为 animate 方法的参数，以更改 begin 和 end 的值。
 CurvedAnimation curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);
 animation = Tween(begin: 0.0, end: 300.0).animate(curve);

============================ 
AnimatedWidget
直接上代码
//...
class AnimState extends State<AnimScreen> with SingleTickerProviderStateMixin {
  Animation<double> animation;
  AnimationController controller;

  @override
  initState() {
    super.initState();
    controller = AnimationController(
        duration: const Duration(milliseconds: 2000), vsync: this);
    // 区别在这里，不需要主动 addListener 中去 setState
    animation = Tween(begin: 0.0, end: 300.0).animate(controller);
    controller.forward();
  }
  
  Widget build(BuildContext context) {
    return AnimatedLogo(animation: animation);
  }
  
  // ...
}
在 build 方法中返回了一个 AnimatedLogo，定义好的 Animation 作为参数。

class AnimatedLogo extends AnimatedWidget {
  AnimatedLogo({Key key, Animation<double> animation})
      : super(key: key, listenable: animation);

  Widget build(BuildContext context) {
    // 外部传递过来的 Animation 对象
    final Animation<double> animation = listenable;
    return Center(
      child: Container(
        margin: EdgeInsets.symmetric(vertical: 10.0),
        height: animation.value,
        width: animation.value,
        child: FlutterLogo(),
      ),
    );
  }
}
看起来 AnimatedLogo 的 build 其实和原来的写法区别不大，但这个 Widget 继承的是 AnimatedWidget，它本身继承自 StatefulWidget。看它的源码

class _AnimatedState extends State<AnimatedWidget> {
  @override
  void initState() {
    super.initState();
    // 对传进来的 Animation 对象 listenable 添加监听，监听里调用 setState
    widget.listenable.addListener(_handleChange);
  }

  @override
  void dispose() {
    // 还做了 removeListener 的操作
    widget.listenable.removeListener(_handleChange);
    super.dispose();
  }
  
  void _handleChange() {
    setState(() {
      // The listenable's state is our build state, and it changed already.
    });
  }
  // ...
}
即自动加了监听，value 变化时调用 setState 修改 UI。同时 dispose 方法中还移除了监听。

状态监听
前面通过 addListener() 监听动画值的变化，还可以通过 addStatusListener() 来监听动画的状态，如动画开始、结束、向前移动或向后移动。

状态由四个值
enum AnimationStatus {
  /// The animation is stopped at the beginning
  dismissed,
  /// The animation is running from beginning to end
  forward,
  /// The animation is running backwards, from end to beginning
  reverse,
  /// The animation is stopped at the end
  completed,
}

修改代码监听状态：
@override
initState() {
  super.initState();
  controller = AnimationController(
      duration: const Duration(milliseconds: 2000), vsync: this);
  animation = Tween(begin: 0.0, end: 300.0).animate(controller);
  animation.addStatusListener((status) {
    print("$status"); // 打印状态
    if (status == AnimationStatus.completed) {
      controller.reverse(); // 动画结束时，反转从尾到头播放，结束的状态是 dismissed
    } else if (status == AnimationStatus.dismissed) {
      controller.forward(); // 重新从头到尾播放
    }
  });
  controller.forward();
}

动画将无限循环
I/flutter (14046): AnimationStatus.forward
I/flutter (14046): AnimationStatus.completed
I/flutter (14046): AnimationStatus.reverse
I/flutter (14046): AnimationStatus.dismissed
I/flutter (14046): AnimationStatus.forward
I/flutter (14046): AnimationStatus.completed
I/flutter (14046): AnimationStatus.reverse
I/flutter (14046): AnimationStatus.dismissed
================================================
 
 

