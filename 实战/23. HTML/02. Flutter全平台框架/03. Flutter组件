参考https://www.jianshu.com/p/4a550651f4b5

基础组件分为文本(Text)、图片(Image)、按钮(xxButton)、输入框(TextField)、单选框(Switch)与复选框(CheckBox)、表单(Form)等等
布局类组件 水平线性布局（Row）、垂直线性布局（Column)、弹性布局(Flex)、流式布局（Wrap|Flow）、层叠布局（Stack|Positioned）

布局类组件
水平线性布局（Row）、垂直线性布局（Column)、弹性布局(Flex)、流式布局（Wrap|Flow）、层叠布局（Stack|Positioned）

线性布局
水平跟垂直都是基层与Flex。基本格式如下
Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.max, //有效，外层Colum高度为整个屏幕
      children: <Widget>[
        Container(
          color: Colors.red,
          child: Column(
            mainAxisSize: MainAxisSize.max,//无效，内层Colum高度为实际高度  
            children: <Widget>[
              Text("hello world "),
              Text("I am Jack "),
            ],
          ),
        )
      ],
    )
基本上跟Android的线性布局一样
crossAxisAlignment：觉得子控件的对齐
mainAxisSize：自身的大小，如果嵌套里面的会没效
children：子控件
还有其他可以看看链接https://book.flutterchina.club/chapter4/row_and_column.html

弹性布局
Flex属性与线性布局类似
Expanded。在Flex容器中可以设置比例
例如下面的代码会按1：2比例占据屏幕
  Flex(
          direction: Axis.horizontal,
          children: <Widget>[
            Expanded(
              flex: 1,
              child: Container(
                height: 30.0,
                color: Colors.red,
              ),
            ),
            Expanded(
              flex: 2,
              child: Container(
                height: 30.0,
                color: Colors.green,
              ),
            ),
          ],
        )
Flexible组件可以使Row、Column、Flex等子组件在主轴方向有填充可用空间的能力(例如，Row在水平方向，Column在垂直方向)，但是它与Expanded组件不同，它不强制子组件填充可用空间。
Expanded组件可以使Row、Column、Flex等子组件在其主轴方向上展开并填充可用空间(例如，Row在水平方向，Column在垂直方向)。如果多个子组件展开，可用空间会被其flex factor(表示扩展的速度、比例)分割。

Expanded的用法：
import 'package:flutter/material.dart';
class LayoutDemo extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      appBar: new AppBar(
        title: new Text('水平方向布局'),
      ),
      body: new Row(
          children: <Widget>[
            new RaisedButton(
              onPressed: () {
                print('点击红色按钮事件');
              },
              color: const Color(0xffcc0000),
              child: new Text('红色按钮'),
            ),
            new Expanded(
              flex: 1,
              child: new RaisedButton(
                onPressed: () {
                  print('点击黄色按钮事件');
                },
                color: const Color(0xfff1c232),
                child: new Text('黄色按钮'),
              ),
            ),
            new RaisedButton(
              onPressed: () {
                print('点击粉色按钮事件');
              },
              color: const Color(0xffea9999),
              child: new Text('粉色按钮'),
            ),
          ]
      ),
    );
  }
}
void main() {
  runApp(
    new MaterialApp(
      title: 'Flutter教程',
      home: new LayoutDemo(),
    ),
  );
}
中间按钮会强制撑开

Flexible的用法：

import 'package:flutter/material.dart';
class LayoutDemo extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      appBar: new AppBar(
        title: new Text('水平方向布局'),
      ),
      body: new Row(
          children: <Widget>[
            new RaisedButton(
              onPressed: () {
                print('点击红色按钮事件');
              },
              color: const Color(0xffcc0000),
              child: new Text('红色按钮'),
            ),
            new Flexible(
              flex: 1,
              child: new RaisedButton(
                onPressed: () {
                  print('点击黄色按钮事件');
                },
                color: const Color(0xfff1c232),
                child: new Text('黄色按钮'),
              ),
            ),
            new RaisedButton(
              onPressed: () {
                print('点击粉色按钮事件');
              },
              color: const Color(0xffea9999),
              child: new Text('粉色按钮'),
            ),
          ]
      ),
    );
  }
}
void main() {
  runApp(
    new MaterialApp(
      title: 'Flutter教程',
      home: new LayoutDemo(),
    ),
  );
}
————————————————
中间按钮不强制撑开
----------------
Container：一个拥有绘制、定位、调整大小的Widget,Flutter 里具体的内容 Weight 没法自己设置宽高了，全得靠诸如：Container 这样的父容器来设置，Container 只能给 width/height 设置具体值和最大最小值
      1· 如果Container没有子Widget，没有height，没有width，没有constraints，并且父窗口提供无限制约束，则Container尝试尽可能小。
      2· 如果Container没有子Widget，没有alignment，而是一个height，width或 constraints提供，Container试图给出这些限制和父Widget的约束相结合，以尽可能小。
      3· 如果Container没有子Widget，没有height，没有width，没有constraints，没有alignment，但是父窗口提供了有界约束，那么Container会扩展以适应父窗口提供 的约束。
      4· 如果Container具有alignment，并且父窗口提供无限制约束，则constraints会尝试围绕子Widget的alignment自身大小。
      5· 如果Container具有alignment，并且父窗口提供有界约束，则constraints会尝试展开以适合父窗口，然后根据alignment将子项置于其自身内。
      6· Container具有子Widget，但没有height，没有width，没有constraints，没有alignment，将父级constraints传递给子级，自身调整大小。
      
      目前看的特征是如果不设置约束,并且父节点为有界,则撑满,如有自控件的话就包裹子控件,设定宽高的话会作用于子节点.
      一般大小的话可以有两种warp content和match_parent,如果有子控件的话相当于warp content,如果在有子控件条件下要match parent的话需要设置
      constraints BoxConstraints.expand()
      
      BoxConstraints当我们不设置宽高尺寸时，minWidth = 0.0 && minHeight = 0.0 && maxWidth = double.infinity && maxHeight = double.infinity;
      
      框架约束：BoxConstraints 
        // 用指定的约束大小创建框架大小
        const BoxConstraints.tightFor({
          double width,
          double height,
        })

        // 创建需要给定宽度或高度的框约束，除非它们是无限的
        const BoxConstraints.tightForFinite({
          double width = double.infinity,
          double height = double.infinity,
        })

        // 创建禁止大小大于给定大小的框约束
        BoxConstraints.loose(Size size)
          : minWidth = 0.0,
            maxWidth = size.width,
            minHeight = 0.0,
            maxHeight = size.height;

        // 创建扩展为填充另一个框约束的框约束
        const BoxConstraints.expand({
          double width,
          double height,
        })
      


SizedBox：一个特定大小的盒子，这个Widget强制它的孩子有一个特性的宽度和高度。如果宽度或高度为Null，则此Widget将调整自身大小以匹配该维度中的孩子的大小
SizedBox 可自定义 width 和 height，当限制宽高时，子 Widget 无论宽高如何，均默认填充；通过设置 double.infinity 填充父类 Widget 宽高，注意此时父类要有限制，不可是无限宽高；当 width 和 height 未设置时，根据子 Widget 大小展示；

1. SizedBox({ Key key, this.width, this.height, Widget child })
sample:
      return SizedBox(width: 100.0, height: 100.0, child: Container(color: Colors.teal.withOpacity(0.4)));
      return SizedBox(width: 100.0, height: 100.0, child: Container(color: Colors.red.withOpacity(0.4), width: 200.0, height: 200.0));
      return SizedBox(width: 100.0, height: 100.0, child: Container(color: Colors.pink.withOpacity(0.4), width: 50.0, height: 50.0));
      return SizedBox(width: double.infinity, height: 100.0, child: Container(color: Colors.blueAccent.withOpacity(0.4)));

2. SizedBox.expand({ Key key, Widget child })
      return SizedBox.expand(child: Container(color: Colors.blueAccent.withOpacity(0.4)));
      
3. SizedBox.shrink({ Key key, Widget child })
      .shrink 同样是便捷方法，但 width 和 height 均为 0.0，无论子 Widget 设置多少均不展示；小菜暂时未想出此类方法的应用场景；
return SizedBox.shrink(child: Container(color: Colors.pink.withOpacity(0.4)));

4. SizedBox.fromSize({ Key key, Widget child, Size size })
      .fromSize 便捷方式与基本的构建方式基本相同，只是 width 和 height 由 Size 封装，小菜用此方法实现与基本方式相同的效果；
      return SizedBox.fromSize(size: Size(100.0, 100.0), child: Container(color: Colors.teal.withOpacity(0.4)));
      return SizedBox.fromSize(size: Size(100.0, 100.0), child: Container(color: Colors.red.withOpacity(0.4), width: 200.0, height: 200.0));
      return SizedBox.fromSize(size: Size(100.0, 100.0), child: Container(color: Colors.pink.withOpacity(0.4), width: 50.0, height: 50.0));
      return SizedBox.fromSize(size: Size(double.infinity, 100.0), child: Container(color: Colors.blueAccent.withOpacity(0.4)));





流式布局
Wrap直接使用，超过屏幕自动换行
Flow需要自己计算，但是性能较好。同时由于是自己计算的，所以换行规则可以自己定。

层叠布局
Stack类似于Android里面的FrameLayout、Web中的绝对定位
Position 结合Stack使用可以实现绝对定位的效果

容器类组件
容器类与布局类不同的地方在于一般容器类只接受一个子组件。用于修饰、变换、限制大小、设置边距等等

Padding
跟移动端不一样的是，flutter的Padding也是单独抽出来的组件。格式如下
Padding(
      //上下左右各添加16像素补白
      padding: EdgeInsets.all(16.0),
      child: Column()

限制类容器(ConstrainedBox、SizedBox等等)
用于限制组件的最大最小值，格式如下，一个是限制条件的属性、一个是child放的内容

ConstrainedBox(
    constraints: BoxConstraints(minWidth: 60.0, minHeight: 100.0),  //父
    child: UnconstrainedBox( //“去除”父级限制
      child: ConstrainedBox(
        constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子
        child: redBox,
      ),
    )
)

装饰器DecoratedBox
类似于Android的shape，可以设置圆角、渐变、阴影等等。格式如下
 DecoratedBox(
    decoration: BoxDecoration(
      gradient: LinearGradient(colors:[Colors.red,Colors.orange[700]]), //背景渐变
      borderRadius: BorderRadius.circular(3.0), //3像素圆角
      boxShadow: [ //阴影
        BoxShadow(
            color:Colors.black54,
            offset: Offset(2.0,2.0),
            blurRadius: 4.0
        )
      ]
    ),
  child: Padding(padding: EdgeInsets.symmetric(horizontal: 80.0, vertical: 18.0),
    child: Text("Login", style: TextStyle(color: Colors.white),),
  )
)

变换Transform
旋转(rotate)、平移(translate)、缩(scale)
DecoratedBox(
  decoration:BoxDecoration(color: Colors.red),
  child: Transform.rotate(
    angle:90 ,
    child: Text("Hello world"),
  ),
)；
这种方式的旋转不会执行build方法，所以背景不会改变性能也较好一些，我的理解是它仅仅改变了child的值，而如果要改变全部则使用RotatedBox

RotatedBox
 DecoratedBox(
      decoration: BoxDecoration(color: Colors.red),
      //将Transform.rotate换成RotatedBox  
      child: RotatedBox(
        quarterTurns: 1, //旋转90度(1/4圈)
        child: Text("Hello world"),
      ),
    
这里没有讲的一个是透明度的变换
Opacity(
        opacity: 0.1,
        child: new Container(
        width: 250.0,
        height: 100.0,
        decoration: new BoxDecoration(
        backgroundColor: const Color(0xff000000),
    ),
)

Container容器
这个容器比较强大的是它有padding跟margin以及变换等等不过底层也是用上面的控件实现的
Container({
  this.alignment,
  this.padding, //容器内补白，属于decoration的装饰范围
  Color color, // 背景色
  Decoration decoration, // 背景装饰
  Decoration foregroundDecoration, //前景装饰
  double width,//容器的宽度
  double height, //容器的高度
  BoxConstraints constraints, //容器大小的限制条件
  this.margin,//容器外补白，不属于decoration的装饰范围
  this.transform, //变换
  this.child,
  padding,
  margin,
})

EdgeInsets.fromLTRB(10,10,10,10) ，L表示左边距（left缩写），T表示上边距（top缩写），R表示右边距（right缩写），B表示底边距（bottom缩写），四个值可以分开写；
EdgeInsets.all（10），上下左右边距均为10；
EdgeInsets.only(left: 10, right: 5, top: 10, bottom: 10)，可分别指定4个方向的边距值，如果只需要上边距，可以写成EdgeInsets.only( top: 10)；
EdgeInsets.symmetric(vertical: 20, horizontal: 10) ，可以指定垂直和水平方向的边距，也可以单独指定垂直或者水平方向的边距。如只需要垂直方向的边距，可写成EdgeInsets.symmetric(vertical: 20)；



Flutter之Center组件
一.参数说明
const Center({ 
    Key key, 
    double widthFactor, 
    double heightFactor, 
    Widget child }
)
1.widthFactor: Center组件的宽度因子
当 widthFactor == null时,Center组件的宽度要多大有多大,相当于android中的 match_parent
当 widthFactor != null时,Center组件的宽度等于 widthFactor*子组件的宽度
2.heightFactor: Center组件的高度因子
当 heightFactor == null时,Center组件的宽度要多大有多大,相当于android中的 match_parent
当 heightFactor != null时,Center组件的高度等于 heightFactor*子组件的高度
3.child: 显示在Center组件内部的子组件,由于受到Center组件的限制,在Center内部居中显示
————————————————
