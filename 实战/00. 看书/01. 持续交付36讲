===01  持续交付到底有什么价值？

1. 持续集成=> 持续交付 => 持续部署(最后一公里)

2. 解决问题
  1) 快速建立测试环境,验证技术方案
  2) DEVOPS平台是天然的标准,规范,流程 载体
  3) 黑天鹅事件,快速回滚
  4) 知识传承, 静态代码检测工具,自动化测试工具是团队的经验产物.
  5) 降低编译,发布时间,专注于业务理解
  6) 代码随时处于可发布状态

3. 量化持续集成的效果
   编译速度->发布速度->自动化测试速度->回滚速度

4. 开发生产中的难点
  1) 开发没有隔离的生产环境
  2) 生产代码回滚了,需手工处理代码分支

===02 影响持续交付的因素有哪些？
  人(组织和文化)    ---组织构成 文化差异
  事(流程)          ---审批流程
  物(架构)          ---产品架构 SOA/单体架构
                    ---单体仓库 代码仓库不断庞大,提交冲突,集成时间变长. 应用变复杂,小修改引起重新编译,需要全回归.
                    ---SOA  应用拆分有利于部署 但是部署变得复杂 需要大规模依赖.

===03 持续交付和DevOps是一对好基友
  Dev：尽可能解决一切Bug 多处修改
  Ops: 尽可能少变更保证软件运行的稳定
  天生为对立和矛盾的状态.
  
  Docker解决基础设施既代码-当前我们的做法是服务器和代码分开部署，但是现在的趋势是代码和vm绑定在一起，或者容器中都已经包含了代码，是当做一个整体部署下去，这样就不会有环境的问题。
  
===04  一切的源头，代码分支策略的选择
  TBD 主干开发 
    优点: 提交在主干头部,各用户看到的一致. 避免合并分支的问题.
    发布分支为主干分支的快照.
    以后Bug修复和功能增强都是提交到主干分支,通过cherry-pick发布到发布分支.
  
  Gitflow 过于繁琐
  
  GithubFlow
          master 包含稳定的代码,即将发布到生产的代码,任何人不能将未经测试的代码发布到master
          BUG修复,功能增强等在单独分支开发,当修改时候从master分支创建一个新分支,开发人员可以自由提交新代码,当新分支代码全部完成后,通过github提交个新的pull request团队其他人员
                  会对代码审核提供相关意见,由jinkins进行自动化测试通过代码审查和自动化测试后会被合并到master.
                  
          1. 令master 分支时常保持可以部署的状态
          2. 使用Github Flow 的前提条件：
          团队规模最好控制在15-20人之内
          
          3. 每个人都应该从主支开始，并一直以主支为基础
          这意味着你不从任何分支开始。你检出主支内容,然后创建你的特性，提交你的合并请求，下次修改还是以主支为基础。在你合并内容到主枝上时，你应该完成审查，不应该包含其他中间阶段的内容。
          4. 先修改主支中的错误，之后发布分支
          
  GitLabFlow
          Gitlab flow 的最大原则叫做"上游优先"（upsteam first），即只存在一个主分支master，它是所有其他分支的"上游"。只有上游分支采纳的代码变化，才能应用到其他分支。
          
  ===06  代码回滚，你真的理解吗？
  
  ===07  “两个披萨”团队的分支管理实践
          
  ===08  测试环境要多少？从现实需求说起
      
          
          
