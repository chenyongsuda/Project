
    作者：C86guli
    链接：https://www.jianshu.com/p/403f3554e2c1

1.花括号展开
    在花括号内，可以是以逗号分隔的字符串，或者是一个序列表达式。在花括号前后，可以跟前缀和后缀。

    花括号展开支持嵌套，展开的字符串是无序的，从左到右的顺序被保留。

    1，逗号分隔

    # echo a{d,c,b}e
    ade ace abe
    前缀 a 和 后缀 e 与展开结果的每一个字符串结合生成最终结果。

2，序列表达式
    序列表达式的语法是：
    '{X..Y[..INCR]}'

    X，Y 是数字或单个字符，INCR 是步进。

    当 X，Y 是数字时，展开为 X 到 Y 的所有数字。数字可加前缀 0，如 01，001，使展开结果保持相同的宽度。

    当 X 或 Y 以 0 开头时，shell 尝试将生成结果保持相同宽度。必要时以 0 进行填充。

    {01..100} 生成 001, 002, ..., 100

    步进：
    {1..10..2} 生成 1 3 5 7 9

    当 X，Y 是字母时，按字典序展开。X，Y 必须是相同类型。当给出步进时，相邻字母的距离为步进的距离。默认步进为 1 或 -1(看具体情况)。

    {a..g..2} 生成 a c e g

    花括号展开在其它展开之前进行，任何对于其它展开有特殊意义的字符都被保留。

3. 波浪线展开
    如果一个单词以未被引用的 '~' 开头，这个单词所有到斜线 '/'(如果有得话) 为止的字符被认为是一个 波浪线前缀字符串（TILDE-PREFIX）。

    如果在 “波浪线前缀字符串” 中没有被引号引用的字符，那么所有波浪线之后的字符组成的字符串被当做可能的 LOGIN NAME 对待。

    如果 LOGIN NAME 是空字符串，'~' 被替换为 'HOME' 变量的值。
    如果 'HOME' 变量没有设置，则替换为执行 shell 的用户的家目录。
    否则，'~' 被替换为与 登录名 关联的家目录。
    下面是 bash 中的波浪线展开的示例：

    '~'
    展开为 '$HOME' 的值

    '~/foo'
    展开为 '$HOME/foo'

    '~fred/foo'
    展开为 用户fred的及目录的子目录foo: /home/fred/foo

    '~+/foo'
    展开为 '$PWD/foo'

    '~-/foo'
    展开为 '{OLDPWD-'~-'}/foo'

    '~N'
    等同于执行 'dirs +N' 的结果

    '~+N'
    等同于执行 'dirs +N' 的结果

    '~-N'
    等同于执行 'dirs -N' 的结果

4.Shell 参数展开
    '$' 符号引入了三种 shell 展开，包括 “参数展开”，“命令替换” 和 “算术表达式”。

    参数名或参数符号可以用花括号括起来，使紧跟在参数名后面的字符与之分隔，这些字符与展开的结果可共同构成最后字符串。如 ${PATH}:/path/to/..

    在参数展开中使用花括号时，'{' 是开始符号，右边第一个 '}' 是结束符号。
    '}' 不能被转义，或被引号引用，也不能在一个嵌套的 “算术表达式”，或 “命令替换”，或者 “参数展开”之中。

    参数展开的基本的形式是 ${PARAMETER}，整体被替换为 PARAMETER 的值。如果 PARAMETER 是位置参数，而且由两个及以上的数字表示，这时必须使用花括号：${10}。另外当 PARAMETER 与其它字符相邻连接时，也必须使用花括号：${Var}lala。

    如果 PARAMETER 的第一个字符是 "!"，会进行“间接变量展开”。bash 使用 "!" 之后的部分作为变量名，变量进行展开，变量展开结果作为被引用的对象再进行一次展开。"!" 符号必须紧跟在左括号 "{" 后面。但是 ${!PREFIX*} 和 ${!NAME[@]} 是例外，在下面会介绍。
    变量展开替换：
    '${PARAMETER:-WORD}'
    '${PARAMETER:=WORD}'
    '${PARAMETER:?WORD}'
    '${PARAMETER:+WORD}'

    '${PARAMETER:OFFSET}'
    '${PARAMETER:OFFSET:LENGTH}'


    '${!PREFIX*}'
    '${!PREFIX@}'
    展开结果为所有以 PREFIX 为前缀的变量的名字。这些变量名以"IFS"变量的第
    一个字符作为分隔符。

    如果用的是@，而且在双引号中展开，每个变量名展开为独立的单词。

    如果用的是*，而且在双引号中展开，所有变量名展开为一个单词。

    #  echo ${!BASH@}
    BASH BASHOPTS BASHPID BASH_ALIASES BASH_ARGC BASH_ARGV BASH_CMDS BASH_COMMAND BASH_LINENO BASH_SOURCE BASH_SUBSHELL BASH_VERSINFO BASH_VERSION

    # for i in "${!BASH*}"; do echo "haha"; done
    haha   <=== 展开为1个单词，所以打印一次。


    # for i in "${!BASH@}"; do echo "haha"; done
    haha  <=== 展开为独立个单词，所以打印多次。
    haha
    haha
    haha
    haha
    haha
    haha
    haha
    haha

    '${!NAME[@]}'
    '${!NAME[*]}'

    如果 NAME 是数组变量，展开为数组索引(key)的列表。

    如果 NAME 不是数组变量，当变量存在时展开为0。

    如果用的是@，而且在双引号中展开，每个key展开为独立的单词。


    '${#PARAMETER}'

    展开为参数值的长度。

    如果参数是“*”或者“@”，展开为位置参数的个数。

    当参数是以@或*为下标的数组，展开为数组中元素的个数。

    '${PARAMETER#WORD}'
    '${PARAMETER##WORD}'

    将 WORD 的展开结果作为匹配模式（如同文件名展开中的通配符匹配），去匹配参数值的开始部分，匹配到的部分将被删除。

    使用“#”，表示最短匹配，

    使用“##”，表示最长匹配。

    如果参数是“*”或者“@”，对每个位置参数做上面的操作，

    当参数是以@或*为下标的数组，对每个数组变量做如上的操作。

    '${PARAMETER%WORD}'
    '${PARAMETER%%WORD}'

    将 WORD 的展开结果作为匹配模式（如同文件名展开中的通配符匹配），从参数值的尾部做匹配，匹配到的部分将被删除。

    使用“#”，表示最短匹配，

    使用“##”，表示最长匹配。

    如果参数是“*”或者“@”，对每个位置参数做上面的操作，

    当参数是以@或*为下标的数组，对每个数组变量做如上的操作。最终结果为所有被处理过的参数的列表。

    '${PARAMETER/PATTERN/STRING}'

    这个可视为上面两个展开的增强版。PATTERN 的展开结果作为匹配模式，对参数的值做最长匹配，匹配的部分替换为 STRING。

    一般只有第一个被匹配的部分才替换为 STRING，但如果 PATTERN 以 '/' 开头，则所有匹配的部分都将被替换。

    如果 PATTERN 以 '#' 开头，它必须从参数值的开始部分进行匹配。

    如果 PATTERN 以 '%' 开头，它必须从参数值的尾部进行匹配。

    如果 STRING=null，匹配的部分将被删除，而且 PATTERN 后面的 '/' 被忽略。

    如果参数是“*”或者“@”，对每个位置参数做上面的操作，

    当参数是以@或*为下标的数组，对每个数组变量做如上的操作。最终结果为所有被处理过的参数的列表。

    '${PARAMETER^PATTERN}'
    '${PARAMETER^^PATTERN}'
    '${PARAMETER,PATTERN}'
    '${PARAMETER,,PATTERN}'

    这个展开用来修改参数值的字符的大小写。

    PATTERN 的展开结果作为匹配模式

    ^ 将匹配的第一个字母的小写改为大写。

    , 将匹配的第一个字母的大写改为小写。

    ^^ 将匹配的所有字母改为大写

    ,, 将匹配的所有字母改为小写

    如果没有给出 PATTERN，则默认将 PATTERN 设为 ?，表示匹配任意一个字符。

    如果参数是“*”或者“@”，对每个位置参数做上面的操作，

    当参数是以@或*为下标的数组，对每个数组变量做如上的操作。最终结果为所有被处理过的参数的列表。


命令替换
    $(COMMAND) 或者 `COMMAND`

算术展开
    $(( EXPRESSION ))
过程替换
单词分割
文件名展开
模式匹配
