1. shell是什么
   shell是一个应用进程
2. shell的变量范围
   本地变量
    作用范围：本shell
   环境变量
    作用范围：本shell和子shell
   
3. shell定义
   本地变量
         变量赋值 name=value
         变量引用 ${name}, $name
              强引用 ''
              弱引用 ""
         查看变量 set
         取消变量 unset
         定义只读变量 readonly name=value
                     declare -r name=value
   
   环境变量
         1. export name=value
         2. name=value 
            export name
         3. declare -x name=value
         4. name=value 
            declare -x 
    bash许多内置环境变量为全大写.

4.多命令一起执行
  ~]# COMMAND01;COMMAND02;COMMAND03
  

5.逻辑运算
   真 (true,yes,on,1)
   假 (false,no,off,0)
   
   与     &&
   或     ||
   非     ！
   异或   ^
   
   运算符的短路法则   COMMAND01 && COMMAND02 第一个命令失败第二个不会执行
                     COMMAND01 || COMMAND02 第一个命令失败第二个就会执行
   
   
6.shell脚本的本质
   shell脚本是命令的堆积,命令自上而下执行,由于命令的非幂等性所有脚本中要进行判断比如命令useradd name如果name存在还会往下执行
   导致脚本停顿的原因会是exit或者命令的拼写错误.
   
   不如如下的写法
   id user3 || useradd user3 表示如果有了就不创建了,没有的话就执行创建.
   
   脚本执行的时候比如脚本test.sh的话
   如果>$ test.sh 这样写的话会去path环境变量找这个,因此需要制定绝对路径 ./test.sh
   
   通过./test.sh 这样执行的话会判断首行中的#!/bin/bash 来使用bash解释器.
   或者手动制定解释器如下：
   bash /xxx/xxx/test.sh
   
插播一个shell写法,纯粹备忘无上下文关系   
#echo hello | passwd --stdin user3 


7.实验
   1)显示/etc目录下以大写或者小写p开头的文件或者目录
   2)显示/var目录下的所有文件或者目录并将结果找那个的小写字母转为大写字母后显示
   3)创建临时文件/tmp/myfile.xxxx
   

8.SHELL 登录类型
   交互式登录 profile
      全局用户范围：
            /etc/profile
            /etc/profile.d/xxx.sh
      个人范围
            在个人目录的~/.bash_profile
      1. 直接账号名密码
      2. su - username
      
      用途：定义环境变量运行命令或者脚本
      
   非交互式登录 bashrc
      全局:
         /etc/bashrc
      个人:
         ~/bashrc
      1. su username
      2. 图形界面打开shell
      3. 运行脚本时候 SHELL 脚本是在子shell中运行的.属于非交互式的登录
      
      用途： 定义本地变量和定义别名
   交互式加载顺序: /etc/profile===>/etc/profile.d/*===>~/.bash_profile===>~/bashrc===>/etc/bashrc
   非交互是加载顺序: ~/bashrc===>/etc/bashrc===>/etc/profile.d/*.sh
   让配置文件立即生效 source 或者 .
================================================================================================   
交互式登录shell和非交互式登录shell的区别
交互式登录：(清除掉所有变量，通过文件重新读入)
(1)直接通过终端输入账号密码登录
(2)使用“su - UserName”切换的用户
执行顺序：（影响该shell的配置文件）
/etc/profile --> /etc/profile.d/*.sh --> ~/.bash_profile--> ~/.bashrc--> /etc/bashrc

非交互式登录：（会继承上一个shell的全部变量）
(1)su UserName
(2)图形界面下打开的终端
(3)执行脚本   （当我们执行脚本的时候.我们就已经进入到了一个子shell）
(4)任何其它的bash实例
执行顺序：（影响该shell的配置文件）

~/.bashrc--> /etc/bashrc--> /etc/profile.d/*.sh

 使用./test.sh或者 bash ./test.sh执行脚本的时候，是开启一个子shell，这个子shell能继承上一个父shell的变量，而这个子shell的变量，随着子shell的退出而消失。当我们用. test.sh 或者source test.sh时，不开启子shell，在当前shell运行，子shell中的所有值都影响当前。

 一般我们对shell进行一些配置的时候，通常都是对~/.bashrc 和/etc/bashrc这两个文件进行一些配置。
 
 ==================================================================================================
 CentOS 7下使用chkconfig添加的服务无法使用/etc/profile里面的环境变量
经过分析/etc/profile为入口的，基本是登录后执行的变量，而使用chkconfig添加的服务多变以守护经常运行，没有登录。

CentOS 7下使用chkconfig添加的服务无法使用/etc/profile里面的环境变量，通过env输出只有:

复制代码
TERM=xterm
SYSTEMCTL_SKIP_REDIRECT=
PATH=/sbin:/usr/sbin:/bin:/usr/bin
PWD=/
SHLVL=1
SYSTEMCTL_IGNORE_DEPENDENCIES=
_=/bin/env
复制代码
所以要想在chkconfig添加的服务里使用环境变量，只有在服务的脚本中引入变量文件，比如:source /etc/profile，但不建议引入这个文件，直接想要哪个变量引入这里面的个别脚本：/etc/profile.d/xxx.sh

但使用systemctl添加的服务，可以通过这个变量设置:

EnvironmentFile
 

参考：

https://stackoverflow.com/questions/42499166/environmental-variables-not-being-picked-up-in-linux-service

https://forums.fedoraforum.org/showthread.php?244785-environment-variables-in-chkconfig

https://unix.stackexchange.com/questions/44370/how-to-make-unix-service-see-environment-variables

https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html

============================================================================================================
1）/etc/profile   登录时，会执行。 
全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 
（2）/ect/bashrc   Ubuntu没有此文件，与之对应的是/ect/bash.bashrc 
bash.bashrc 是交互式shell的初始化文件。   
（3）~/.profile  某个用户读取的配置。 
若bash是以login方式执行时，读取~/.bash_profile，若它不存在，则读取~ /.bash_login，若前两者不存在，读取~ /.profile。 
另外，图形模式登录时，此文件将被读取，即使存在~/.bash_profile和~/.bash_login。 
（4）~/.bash_login    
若 bash是以login方式执行时，读取~/.bash_profile，若它不存在，则读取~/.bash_login，若前两者不存在，读取~ /.profile。 
（5）~/.bash_profile   Unbutu默认没有此文件，可新建。 
只有 bash是以login形式执行时，才会读取此文件。通常该配置文件还会配置成去读取~/.bashrc。 
（6）~/.bashrc     该文件包含专用于某个用户的bash shell的bash信息,当该用户登录时以及每次打开新的shell时,该文件被读取. 
当 bash是以non-login形式执行时，读取此文件。若是以login形式执行，则不会读取此文件。 
（7）~/.bash_logout 
注销时，且是longin形式，此文件才会读取。也就是说，在文本模式注销时，此文件会被读取，图形模式注销时，此文件不会被读取。 
补充一点，/etc/rc.local是系统shell会执行的文件，linux启动后会退出的；/etc/profile 或 /etc/bash.bashrc是用户shell会的配置，我们一般的Shell是用户Shell的子进程，而非系统shell的子进程，所以如果在 /etc/rc.local中指定"alias ll='ls -a'"这样的别名，对登录系统后的shell是没用的。 
某网友总结如下： 
/etc/profile，/etc /bashrc 是系统全局环境变量设定   
/etc/profile与/etc/bashrc的区别？ 
前一个主要用来设置一些系统变量,比如JAVA_HOME等等,后面一个主要用来保存一些bash的设置.   
~/.profile，~ /.bashrc用户家目录下的私有环境变量设定 
当登入系统时候获得一个shell进程时，其读取环境设定档有三步 
1 首先读入的是全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如 
/etc/profile.d和 /etc/inputrc 
2 然后根据不同使用者帐号，去其家目录读取~/.bash_profile，如果这读取不了就读取~/.bash_login，这个也读取不了才会读取 
~/.profile，这三个文档设定基本上是一样的，读取有优先关系 
3 然后在根据用户帐号读取~/.bashrc 
至于~/.profile与~/.bashrc的区别，都具有个性化定制功能 
~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次 
~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次 
下面是几个例子： 
1. 图形模式登录时，顺序读取：/etc/profile和~/.profile 
2. 图形模式登录后，打开终端时，顺序读取：/etc/bash.bashrc和~/.bashrc 
3. 文本模式登录时，顺序读取：/etc/bash.bashrc，/etc/profile和~/.bash_profile 
4. 从其它用户su到该用户，则分两种情况： 
    （1）如果带-l参数（或-参数，--login参数），如：su -l username，则bash是lonin的，它将顺序读取以下配置文件：/etc/bash.bashrc，/etc/profile和~ /.bash_profile。 
    （2）如果没有带-l参数，则bash是non-login的，它将顺序读取：/etc/bash.bashrc和~/.bashrc 
5. 注销时，或退出su登录的用户，如果是longin方式，那么bash会读取：~/.bash_logout 
6. 执行自定义的shell文件时，若使用“bash -l a.sh”的方式，则bash会读取行：/etc/profile和~/.bash_profile，若使用其它方式，如：bash a.sh， ./a.sh，sh a.sh（这个不属于bash shell），则不会读取上面的任何文件。 
7. 上面的例子凡是读取到~/.bash_profile的，若该文件不存在，则读取~/.bash_login，若前两者不存在，读取~ /.profile。

================================================================================================================
linux读取profile文件和bashrc文件的情况
    最近研究linux，对linux的profile文件和bashrc文件有些不清楚，于是深入研究了一下。
    如果想知道这些文件什么时候被执行，还需要知道几个关于shell的小知识。（CentOS6.5 linux）

    1.login shell，登录shell，即init 3启动linux后，需要输入用户名和密码，进入的shell就是loginshell。
       注意：在shell里使用su - user_name 切换用户，登录的shell也是login shell
       login shell会读取的文件有：/etc/profile，$HOME/.bash_profile,$HOME/.bash_login，$HOME/.profile，按以上顺序读取。

    2.有login shell就有no login shell。
       no login shell有，在login  shell中输入bash，没有输入用户名和密码，那么这个就是no login shell。

       在图形界面下，打开一个shell也是no login shell
        no login shell 在打开的时候，执行的文件是$HOME/.bashrc,而.bashrc又会执行/etc/bashrc文件（可查看家目录的.bashrc文件）。

       下面是一张简单的流程图：
       举例：1.在非图形界面，如果要配置PS1这个环境变量，最好配置到/etc/profile或是$HOME/.bash_profile中，这样登出在登录一下，就会执行这个命令
            2.如果是图形界面的用户，配置PS1，需要配置的时$HOME/.bashrc文件，或是/etc/bashrc文件，因为打开no login shell的时候，读取的时
            $HOME/.bashrc(这个文件会读取/etc/bashrc)这个文件。
            
说成login和no login更好理解点.

实际测试的时候发现使用命令#bash的话会调用/etc/bashrc
但是执行脚本bash xxx.sh 或者 ./xxx.sh 不会调用想不通继续查清楚.

========================================================================================================
注意SHELL子进程会继承环境变量 但是别名不会继承,默认子进程不开启别名扩展如下解释
Linux shell有交互式与非交互式两种工作模式。我们日常使用shell输入命令得到结果的方式是交互式的方式，而shell脚本使用的是非交互式方式。 
shell提供了alias功能来简化我们的日常操作，使得我们可以为一个复杂的命令取一个简单的名字，从而提高我们的工作效率。在交互式模式下，shell的alias扩展功能是打开的，因此我们可以键入自己定义的alias别名来执行对应的命令。
但是，在非交互式模式下alias扩展功能默认是关闭的，此时仍然可以定义alias别名，但是shell不会将alias别名扩展成对应的命令，而是将alias别名本身当作命令执行，如果shell内置命令和PATH中均没有与alias别名同名的命令，则shell会“抱怨”找不到指定的命令。
那么，有没有办法在非交互式模式下启用alias扩展呢？答案是使用shell内置命令shopt命令来开启alias扩展选项。shopt是shell的内置命令，可以控制shell功能选项的开启和关闭，从而控制shell的行为。shopt的使用方式如下：
shopt -s opt_name                 Enable (set) opt_name.
shopt -u opt_name                 Disable (unset) opt_name.
shopt opt_name                    Show current status of opt_name.
alias扩展功能的选项名称是expand_aliases，我们可以在交互式模式下查看此选项是否开启：
sw@gentoo ~ $ shopt expand_aliases
expand_aliases  on
sw@gentoo ~ $
可见在交互式模式下alias扩展功能的确是开启的，因此我们才能使用alias别名。
 
我们编写一个脚本来验证一下非交互式模式下alias扩展的设置：
#!/bin/bash --login

alias echo_hello="echo Hello!"
shopt expand_aliases   
echo_hello

shopt -s  expand_aliases  
shopt expand_aliases   
echo_hello

脚本执行结果如下：
sw@gentoo ~ $ ./test.sh 
expand_aliases  off
./test.sh: line 5: echo_hello: command not found
expand_aliases  on
Hello!
sw@gentoo ~ $

可以看到，在非交互式模式下alias扩展功能默认是关闭的，但是我们可以用shopt来将其开启。 
另外，alias别名只在当前shell有效，不能被子shell继承，也不能像环境变量一样export。可以把alias别名定义写在.bashrc文件中，这样如果启动交互式的子shell，则子shell会读取.bashrc，从而得到alias别名定义。但是执行shell脚本时，启动的子shell处于非交互式模式，是不会读取.bashrc的。
不过，如果你一定要让执行shell脚本的子shell读取.bashrc的话，可以给shell脚本第一行的解释器加上参数：
#!/bin/bash --login
--login使得执行脚本的子shell成为一个login shell，login shell会读取系统和用户的profile及rc文件，因此用户自定义的.bashrc文件中的内容将在执行脚本的子shell中生效。
还有一个简单的办法让执行脚本的shell读取.bashrc，在脚本中主动source ~/.bashrc即可。

