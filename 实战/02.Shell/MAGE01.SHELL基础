1. shell是什么
   shell是一个应用进程
2. shell的变量范围
   本地变量
    作用范围：本shell
   环境变量
    作用范围：本shell和子shell
   
3. shell定义
   本地变量
         变量赋值 name=value
         变量引用 ${name}, $name
              强引用 ''
              弱引用 ""
         查看变量 set
         取消变量 unset
         定义只读变量 readonly name=value
                     declare -r name=value
   
   环境变量
         1. export name=value
         2. name=value 
            export name
         3. declare -x name=value
         4. name=value 
            declare -x 
    bash许多内置环境变量为全大写.
   
   3.1 SHELL 为弱类型,SHELL变量类型为字符型和数字型(无浮点型)默认变量都解释为字符型. 
         
         算术运算：
        +, -, *, /, %, **
         
        let  VAR=expression
        VAR=$[expression]        这个比较常用
        VAR=$((expression))
        VAR=$(expr argu1 argu2 argu3) 这里其实算数计算为expr argu1 argu2 argu3 通过命令运算符$()取到命令标准输出
         
        注意：有些时候乘法符号需要转义；
         
        增强型赋值：
            变量做某种算术运算后回存至此变量中；
                let i=$i+#
                let i+=#
                 
            +=，-=，*=, /=, %=
             
            自增：
                VAR=$[$VAR+1]
                let  VAR+=1
                let  VAR++
                 
            自减：
                VAR=$[$VAR-1]
                let  VAR-=1
                let  VAR--
                 
    练习：
        1、写一个脚本
            计算/etc/passwd文件中的第10个用户和第20个用户的id号之和；
                id1=$(head -10  /etc/passwd | tail -1  | cut  -d:  -f3)
                id2=$(head -20   /etc/passwd | tail -1  | cut  -d:  -f3)
                 
             
        2、写一个脚本
            计算/etc/rc.d/init.d/functions和/etc/inittab文件的空白行数之和；
             
                grep "^[[:space:]]*$"   /etc/rc.d/init.d/functions | wc -l
     条件测试：
        判断某需求是否满足，需要由测试机制来实现；
         
        如何编写测试表达式以实现所需的测试：
            (1) 执行命令，并利用命令状态返回值来判断；
                0：成功
                1-255：失败
            (2) 测试表达式
                test  EXPRESSION
                [ EXPRESSION ]
                [[ EXPRESSION ]]
                 
                注意：EXPRESSION两端必须有空白字符，否则为语法错误；
                 
        bash的测试类型：
            数值测试
            字符串测试
            文件测试
             
            数值测试：数值比较
                -eq：是否等于； [ $num1 -eq $num2 ]
                -ne：是否不等于；
                -gt：是否大于；
                -ge：是否大于等于；
                -lt：是否小于；
                -le：是否小于等于；
                 
            字符串测试：
                ==：是否等于；
                >：是否大于；
                <：是否小于；
                !=：是否不等于；
                =~：左侧字符串是否能够被右侧的PATTERN所匹配；
                 
                -z "STRING"：判断指定的字串是否为空；空则为真，不空则假；
                -n "STRING"：判断指定的字符串是否不空；不空则真，空则为假；
                 
                注意：
                    (1) 字符串要加引用；
                    (2) 要使用[[ ]]；
                     
            文件测试：
                存在性测试
                    -a  FILE
                    -e  FILE
                        文件的存在性测试，存在则为真，否则则为假；
                存在性及类型测试
                    -b  FILE：是否存在并且为 块设备 文件；
                    -c  FILE：是否存在并且为 字符设备 文件；
                    -d  FILE：是否存在并且为 目录文件；
                    -f  FILE：是否存在并且为 普通文件；
                    -h  FILE或 -L  FILE：是否存在并且为 符号链接文件；
                    -p FILE：是否存在且为 命名管道文件；
                    -S  FILE：是否存在且为 套接字文件；
                文件权限测试：
                    -r  FILE：是否存在并且 对当前用户可读；
                    -w  FILE：是否存在并且 对当前用户可写；
                    -x  FILE：是否存在并且 对当前用户可执行；
                特殊权限测试：
                    -u  FILE：是否存在并且 拥有suid权限；
                    -g  FILE：是否存在并且 拥有sgid权限；
                    -k  FILE：是否存在并且 拥有sticky权限；
                文件是否有内容：
                    -s  FILE：是否有内容；
                时间戳：
                    -N FILE：文件自从上一次读操作后是否被修改过；
                从属关系测试：
                    -O  FILE：当前用户是否为文件的属主；
                    -G  FILE：当前用户是否属于文件的属组；
                双目测试：
                    FILE1  -ef  FILE2：FILE1与FILE2是否指向同一个文件系统的相同inode的硬链接；
                    FILE1  -nt  FILE2：FILE1是否新于FILE2；
                    FILE1  -ot  FILE2：FILE1是否旧于FILE2；
                     
            组合测试条件：
                逻辑运算：
                    第一种方式：
                        COMMAND1 && COMMAND2
                        COMMAND1 || COMMAND2
                        ! COMMAND
                         
                        [ -O FILE ] && [ -r FILE ]
                         
                    第二种方式：
                        EXPRESSION1  -a  EXPRESSION2
                        EXPRESSION1  -o  EXPRESSION2
                        ! EXPRESSION
                         
                        [ -O FILE -a -x FILE ]
                         
                练习：将当前主机名称保存至hostName变量中；
                    主机名如果为空，或者为localhost.localdomain，则将其设置为www.magedu.com；
                     
                    hostName=$(hostname)
                     
                    [ -z "$hostName" -o "$hostName" == "localhost.localdomain" -o "$hostName" == "localhost" ] && hostname www.magedu.com                  
                     
        脚本的状态返回值：
            默认是脚本中执行的最后一条件命令的状态返回值；
            自定义状态退出状态码：
                exit  [n]：n为自己指定的状态码；
                    注意：shell进程遇到exit时，即会终止，因此，整个脚本执行即为结束；
                     
    向脚本传递参数：
        位置参数变量
         
        myscript.sh  argu1 argu2
            引用方式：
                $1,  $2, ..., ${10}, ${11}, ...
                 
            轮替：
                shift  [n]：位置参数轮替；
                 
        练习：写一脚本，通过命令传递两个文本文件路径给脚本，计算其空白行数之和；
             
            #!/bin/bash
            #
            file1_lines=$(grep "^$" $1 | wc -l)
            file2_lines=$(grep "^$" $2 | wc -l)
 
            echo "Total blank lines: $[$file1_lines+$file2_lines]" 
             
    特殊变量：
        $0：脚本文件路径本身；
        $#：脚本参数的个数；
        $*：所有参数
        $@：所有参数
 
    过程式编程语言的代码执行顺序：
        顺序执行：逐条运行；
        选择执行：
            代码有一个分支：条件满足时才会执行；
            两个或以上的分支：只会执行其中一个满足条件的分支；
        循环执行：
            代码片断（循环体）要执行0、1或多个来回；
             
        选择执行：
            单分支的if语句：
                if  测试条件
                then
                    代码分支
                fi
             
            双分支的if语句：
                if  测试条件; then
                    条件为真时执行的分支
                else
                    条件为假时执行的分支
                fi
                 
        示例：通过参数传递一个用户名给脚本，此用户不存时，则添加之；
            #!/bin/bash
            #
            if ! grep "^$1\>" /etc/passwd &> /dev/null; then
                useradd $1
                echo $1 | passwd --stdin $1 &> /dev/null
                echo "Add user $1 finished."
            fi 
             
            #!/bin/bash
            #
            if [ $# -lt 1 ]; then
                echo "At least one username."
                exit 2
            fi
 
            if ! grep "^$1\>" /etc/passwd &> /dev/null; then
                useradd $1
                echo $1 | passwd --stdin $1 &> /dev/null
                echo "Add user $1 finished."
            fi     
                 
            #!/bin/bash
            #
            if [ $# -lt 1 ]; then
                echo "At least one username."
                exit 2
            fi
 
            if grep "^$1\>" /etc/passwd &> /dev/null; then
                echo "User $1 exists."
            else
                useradd $1
                echo $1 | passwd --stdin $1 &> /dev/null
                echo "Add user $1 finished."
            fi         
             
        练习1：通过命令行参数给定两个数字，输出其中较大的数值；
            #!/bin/bash
            #
            if [ $# -lt 2 ]; then
                echo "Two integers."
                exit 2
            fi
 
            if [ $1 -ge $2 ]; then
                echo "Max number: $1."
            else
                echo "Max number: $2."
            fi
 
             
            #!/bin/bash
            #
 
            if [ $# -lt 2 ]; then
                echo "Two integers."
                exit 2
            fi
 
            declare -i max=$1
 
            if [ $1 -lt $2 ]; then
                max=$2
            fi
 
            echo "Max number: $max."
                     
        练习2：通过命令行参数给定一个用户名，判断其ID号是偶数还是奇数；
        练习3：通过命令行参数给定两个文本文件名，如果某文件不存在，则结束脚本执行；
            都存在时返回每个文件的行数，并说明其中行数较多的文件；
         
         
    练习：
        1、创建一个20G的文件系统，块大小为2048，文件系统ext4，卷标为TEST，要求此分区开机后自动挂载至/testing目录，且默认有acl挂载选项；
            (1) 创建20G分区；
            (2) 格式化：
                mke2fs -t ext4 -b 2048 -L 'TEST' /dev/DEVICE
            (3) 编辑/etc/fstab文件
            LABEL='TEST'    /testing    ext4    defaults,acl    0 0
 
        2、创建一个5G的文件系统，卷标HUGE，要求此分区开机自动挂载至/mogdata目录，文件系统类型为ext3；
 
        3、写一个脚本，完成如下功能：
            (1) 列出当前系统识别到的所有磁盘设备；
            (2) 如磁盘数量为1，则显示其空间使用信息；
                否则，则显示最后一个磁盘上的空间使用信息；
                if [ $disks -eq 1 ]; then
                    fdisk -l /dev/[hs]da
                else
                    fdisk -l $(fdisk -l /dev/[sh]d[a-z] | grep -o "^Disk /dev/[sh]d[a-]" | tail -1 | cut -d' ' -f2)
                fi
4.多命令一起执行
  ~]# COMMAND01;COMMAND02;COMMAND03
  

5.逻辑运算
   真 (true,yes,on,1)
   假 (false,no,off,0)
   
   与     &&
   或     ||
   非     ！
   异或   ^
   
   运算符的短路法则   COMMAND01 && COMMAND02 第一个命令失败第二个不会执行
                     COMMAND01 || COMMAND02 第一个命令失败第二个就会执行
   
   
6.shell脚本的本质
   shell脚本是命令的堆积,命令自上而下执行,由于命令的非幂等性所有脚本中要进行判断比如命令useradd name如果name存在还会往下执行
   导致脚本停顿的原因会是exit或者命令的拼写错误.
   
   不如如下的写法
   id user3 || useradd user3 表示如果有了就不创建了,没有的话就执行创建.
   
   脚本执行的时候比如脚本test.sh的话
   如果>$ test.sh 这样写的话会去path环境变量找这个,因此需要制定绝对路径 ./test.sh
   
   通过./test.sh 这样执行的话会判断首行中的#!/bin/bash 来使用bash解释器.
   或者手动制定解释器如下：
   bash /xxx/xxx/test.sh
   
插播一个shell写法,纯粹备忘无上下文关系   
#echo hello | passwd --stdin user3 


7.实验
   1)显示/etc目录下以大写或者小写p开头的文件或者目录
   2)显示/var目录下的所有文件或者目录并将结果找那个的小写字母转为大写字母后显示
   3)创建临时文件/tmp/myfile.xxxx
   

8.SHELL 登录类型
   交互式登录 profile
      全局用户范围：
            /etc/profile
            /etc/profile.d/xxx.sh
      个人范围
            在个人目录的~/.bash_profile
      1. 直接账号名密码
      2. su - username
      
      用途：定义环境变量运行命令或者脚本
      
   非交互式登录 bashrc
      全局:
         /etc/bashrc
      个人:
         ~/bashrc
      1. su username
      2. 图形界面打开shell
      3. 运行脚本时候 SHELL 脚本是在子shell中运行的.属于非交互式的登录
      
      用途： 定义本地变量和定义别名
   交互式加载顺序: /etc/profile===>/etc/profile.d/*===>~/.bash_profile===>~/bashrc===>/etc/bashrc
   非交互是加载顺序: ~/bashrc===>/etc/bashrc===>/etc/profile.d/*.sh
   让配置文件立即生效 source 或者 .
================================================================================================   
交互式登录shell和非交互式登录shell的区别
交互式登录：(清除掉所有变量，通过文件重新读入)
(1)直接通过终端输入账号密码登录
(2)使用“su - UserName”切换的用户
执行顺序：（影响该shell的配置文件）
/etc/profile --> /etc/profile.d/*.sh --> ~/.bash_profile--> ~/.bashrc--> /etc/bashrc

非交互式登录：（会继承上一个shell的全部变量）
(1)su UserName
(2)图形界面下打开的终端
(3)执行脚本   （当我们执行脚本的时候.我们就已经进入到了一个子shell）
(4)任何其它的bash实例
执行顺序：（影响该shell的配置文件）

~/.bashrc--> /etc/bashrc--> /etc/profile.d/*.sh

 使用./test.sh或者 bash ./test.sh执行脚本的时候，是开启一个子shell，这个子shell能继承上一个父shell的变量，而这个子shell的变量，随着子shell的退出而消失。当我们用. test.sh 或者source test.sh时，不开启子shell，在当前shell运行，子shell中的所有值都影响当前。

 一般我们对shell进行一些配置的时候，通常都是对~/.bashrc 和/etc/bashrc这两个文件进行一些配置。
 
 ==================================================================================================
 CentOS 7下使用chkconfig添加的服务无法使用/etc/profile里面的环境变量
经过分析/etc/profile为入口的，基本是登录后执行的变量，而使用chkconfig添加的服务多变以守护经常运行，没有登录。

CentOS 7下使用chkconfig添加的服务无法使用/etc/profile里面的环境变量，通过env输出只有:

复制代码
TERM=xterm
SYSTEMCTL_SKIP_REDIRECT=
PATH=/sbin:/usr/sbin:/bin:/usr/bin
PWD=/
SHLVL=1
SYSTEMCTL_IGNORE_DEPENDENCIES=
_=/bin/env
复制代码
所以要想在chkconfig添加的服务里使用环境变量，只有在服务的脚本中引入变量文件，比如:source /etc/profile，但不建议引入这个文件，直接想要哪个变量引入这里面的个别脚本：/etc/profile.d/xxx.sh

但使用systemctl添加的服务，可以通过这个变量设置:

EnvironmentFile
 

参考：

https://stackoverflow.com/questions/42499166/environmental-variables-not-being-picked-up-in-linux-service

https://forums.fedoraforum.org/showthread.php?244785-environment-variables-in-chkconfig

https://unix.stackexchange.com/questions/44370/how-to-make-unix-service-see-environment-variables

https://coreos.com/os/docs/latest/using-environment-variables-in-systemd-units.html

============================================================================================================
1）/etc/profile   登录时，会执行。 
全局（公有）配置，不管是哪个用户，登录时都会读取该文件。 
（2）/ect/bashrc   Ubuntu没有此文件，与之对应的是/ect/bash.bashrc 
bash.bashrc 是交互式shell的初始化文件。   
（3）~/.profile  某个用户读取的配置。 
若bash是以login方式执行时，读取~/.bash_profile，若它不存在，则读取~ /.bash_login，若前两者不存在，读取~ /.profile。 
另外，图形模式登录时，此文件将被读取，即使存在~/.bash_profile和~/.bash_login。 
（4）~/.bash_login    
若 bash是以login方式执行时，读取~/.bash_profile，若它不存在，则读取~/.bash_login，若前两者不存在，读取~ /.profile。 
（5）~/.bash_profile   Unbutu默认没有此文件，可新建。 
只有 bash是以login形式执行时，才会读取此文件。通常该配置文件还会配置成去读取~/.bashrc。 
（6）~/.bashrc     该文件包含专用于某个用户的bash shell的bash信息,当该用户登录时以及每次打开新的shell时,该文件被读取. 
当 bash是以non-login形式执行时，读取此文件。若是以login形式执行，则不会读取此文件。 
（7）~/.bash_logout 
注销时，且是longin形式，此文件才会读取。也就是说，在文本模式注销时，此文件会被读取，图形模式注销时，此文件不会被读取。 
补充一点，/etc/rc.local是系统shell会执行的文件，linux启动后会退出的；/etc/profile 或 /etc/bash.bashrc是用户shell会的配置，我们一般的Shell是用户Shell的子进程，而非系统shell的子进程，所以如果在 /etc/rc.local中指定"alias ll='ls -a'"这样的别名，对登录系统后的shell是没用的。 
某网友总结如下： 
/etc/profile，/etc /bashrc 是系统全局环境变量设定   
/etc/profile与/etc/bashrc的区别？ 
前一个主要用来设置一些系统变量,比如JAVA_HOME等等,后面一个主要用来保存一些bash的设置.   
~/.profile，~ /.bashrc用户家目录下的私有环境变量设定 
当登入系统时候获得一个shell进程时，其读取环境设定档有三步 
1 首先读入的是全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如 
/etc/profile.d和 /etc/inputrc 
2 然后根据不同使用者帐号，去其家目录读取~/.bash_profile，如果这读取不了就读取~/.bash_login，这个也读取不了才会读取 
~/.profile，这三个文档设定基本上是一样的，读取有优先关系 
3 然后在根据用户帐号读取~/.bashrc 
至于~/.profile与~/.bashrc的区别，都具有个性化定制功能 
~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次 
~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次 
下面是几个例子： 
1. 图形模式登录时，顺序读取：/etc/profile和~/.profile 
2. 图形模式登录后，打开终端时，顺序读取：/etc/bash.bashrc和~/.bashrc 
3. 文本模式登录时，顺序读取：/etc/bash.bashrc，/etc/profile和~/.bash_profile 
4. 从其它用户su到该用户，则分两种情况： 
    （1）如果带-l参数（或-参数，--login参数），如：su -l username，则bash是lonin的，它将顺序读取以下配置文件：/etc/bash.bashrc，/etc/profile和~ /.bash_profile。 
    （2）如果没有带-l参数，则bash是non-login的，它将顺序读取：/etc/bash.bashrc和~/.bashrc 
5. 注销时，或退出su登录的用户，如果是longin方式，那么bash会读取：~/.bash_logout 
6. 执行自定义的shell文件时，若使用“bash -l a.sh”的方式，则bash会读取行：/etc/profile和~/.bash_profile，若使用其它方式，如：bash a.sh， ./a.sh，sh a.sh（这个不属于bash shell），则不会读取上面的任何文件。 
7. 上面的例子凡是读取到~/.bash_profile的，若该文件不存在，则读取~/.bash_login，若前两者不存在，读取~ /.profile。

================================================================================================================
linux读取profile文件和bashrc文件的情况
    最近研究linux，对linux的profile文件和bashrc文件有些不清楚，于是深入研究了一下。
    如果想知道这些文件什么时候被执行，还需要知道几个关于shell的小知识。（CentOS6.5 linux）

    1.login shell，登录shell，即init 3启动linux后，需要输入用户名和密码，进入的shell就是loginshell。
       注意：在shell里使用su - user_name 切换用户，登录的shell也是login shell
       login shell会读取的文件有：/etc/profile，$HOME/.bash_profile,$HOME/.bash_login，$HOME/.profile，按以上顺序读取。

    2.有login shell就有no login shell。
       no login shell有，在login  shell中输入bash，没有输入用户名和密码，那么这个就是no login shell。

       在图形界面下，打开一个shell也是no login shell
        no login shell 在打开的时候，执行的文件是$HOME/.bashrc,而.bashrc又会执行/etc/bashrc文件（可查看家目录的.bashrc文件）。

       下面是一张简单的流程图：
       举例：1.在非图形界面，如果要配置PS1这个环境变量，最好配置到/etc/profile或是$HOME/.bash_profile中，这样登出在登录一下，就会执行这个命令
            2.如果是图形界面的用户，配置PS1，需要配置的时$HOME/.bashrc文件，或是/etc/bashrc文件，因为打开no login shell的时候，读取的时
            $HOME/.bashrc(这个文件会读取/etc/bashrc)这个文件。
            
说成login和no login更好理解点.

实际测试的时候发现使用命令#bash的话会调用/etc/bashrc
但是执行脚本bash xxx.sh 或者 ./xxx.sh 不会调用想不通继续查清楚.

========================================================================================================
注意SHELL子进程会继承环境变量 但是别名不会继承,默认子进程不开启别名扩展如下解释
Linux shell有交互式与非交互式两种工作模式。我们日常使用shell输入命令得到结果的方式是交互式的方式，而shell脚本使用的是非交互式方式。 
shell提供了alias功能来简化我们的日常操作，使得我们可以为一个复杂的命令取一个简单的名字，从而提高我们的工作效率。在交互式模式下，shell的alias扩展功能是打开的，因此我们可以键入自己定义的alias别名来执行对应的命令。
但是，在非交互式模式下alias扩展功能默认是关闭的，此时仍然可以定义alias别名，但是shell不会将alias别名扩展成对应的命令，而是将alias别名本身当作命令执行，如果shell内置命令和PATH中均没有与alias别名同名的命令，则shell会“抱怨”找不到指定的命令。
那么，有没有办法在非交互式模式下启用alias扩展呢？答案是使用shell内置命令shopt命令来开启alias扩展选项。shopt是shell的内置命令，可以控制shell功能选项的开启和关闭，从而控制shell的行为。shopt的使用方式如下：
shopt -s opt_name                 Enable (set) opt_name.
shopt -u opt_name                 Disable (unset) opt_name.
shopt opt_name                    Show current status of opt_name.
alias扩展功能的选项名称是expand_aliases，我们可以在交互式模式下查看此选项是否开启：
sw@gentoo ~ $ shopt expand_aliases
expand_aliases  on
sw@gentoo ~ $
可见在交互式模式下alias扩展功能的确是开启的，因此我们才能使用alias别名。
 
我们编写一个脚本来验证一下非交互式模式下alias扩展的设置：
#!/bin/bash --login

alias echo_hello="echo Hello!"
shopt expand_aliases   
echo_hello

shopt -s  expand_aliases  
shopt expand_aliases   
echo_hello

脚本执行结果如下：
sw@gentoo ~ $ ./test.sh 
expand_aliases  off
./test.sh: line 5: echo_hello: command not found
expand_aliases  on
Hello!
sw@gentoo ~ $

可以看到，在非交互式模式下alias扩展功能默认是关闭的，但是我们可以用shopt来将其开启。 
另外，alias别名只在当前shell有效，不能被子shell继承，也不能像环境变量一样export。可以把alias别名定义写在.bashrc文件中，这样如果启动交互式的子shell，则子shell会读取.bashrc，从而得到alias别名定义。但是执行shell脚本时，启动的子shell处于非交互式模式，是不会读取.bashrc的。
不过，如果你一定要让执行shell脚本的子shell读取.bashrc的话，可以给shell脚本第一行的解释器加上参数：
#!/bin/bash --login
--login使得执行脚本的子shell成为一个login shell，login shell会读取系统和用户的profile及rc文件，因此用户自定义的.bashrc文件中的内容将在执行脚本的子shell中生效。
还有一个简单的办法让执行脚本的shell读取.bashrc，在脚本中主动source ~/.bashrc即可。

====================================================================================================
2、sh/bash
sh a.sh
bash a.sh
都是打开一个subshell去读取、执行a.sh，而a.sh不需要有"执行权限"
通常在subshell里运行的脚本里设置变量，不会影响到父shell的。


3、./
./a.sh
#bash: ./a.sh: 权限不够
chmod +x a.sh
./a.sh
打开一个subshell去读取、执行a.sh，但a.sh需要有"执行权限"
可以用chmod +x添加执行权限

如果脚本上加上
#!/bin/bash --login
并用bash xxx.sh 就会先loadrc等文件 类似于通过bash 然后再这个新bash里面执行命令
如果./xxx.sh就不会重新load rc等文件.

如果是#!/bin/bash表示非登陆非交互脚本,无论bash或者./都不会loadrc等文件.
